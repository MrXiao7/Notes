**传递数组参数**

传递数组也是通过堆栈操作，传递数组的话首先要获取数组的长度

数组的出长度通过luaL_getn(L,1)来获取，数组的长度会存放在栈底

获取到数组的长度用循环来遍历即可，取数组的值通过lua_pushnumber(L,i)(注意，Lua数组的下标是1开始的)，压入栈表示是我们要取数组第i个位置的值，压入后再使用lua_gettable(L,1) 这个函数会弹出数组索引 然后把数组第i元素压入栈，再通过lua_to....即可取出来数组的元素

![image-20240108231239123](notesimg/image-20240108231239123-17047268147681.png)



**传递表参数**

传递表通过lua_next函数来获取，该函数从栈顶弹出一个key,从栈指定位置取出下一对key-value,先将key入栈，再将value入栈，失败返回0

![image-20240108231248411](notesimg/image-20240108231248411-17047268166562.png)

如果只要取某个key对应的value的话，使用lua_getfield函数即可

![image-20240108231256829](notesimg/image-20240108231256829-17047268184923.png)

**参数检查**

通过luaL_checktype函数来检查，但是这个函数如果检查类型不对的话就不会继续执行，如lua_checktype(L,1,LUA_TNUMBER)

![image-20240108231305635](notesimg/image-20240108231305635-17047268201994.png)

类型正确时

![image-20240108231314457](notesimg/image-20240108231314457-17047268220645.png)

类型错误时

这种方法最大的缺点就是一旦类型错误就不会继续往下执行，还可以通过lua_type(L,n) != LUA_TNUMBER来做检查

![image-20240108231322961](notesimg/image-20240108231322961-17047268238486.png)