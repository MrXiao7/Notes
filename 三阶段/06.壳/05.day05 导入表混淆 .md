重定位表修复意义不大,一般都是修导入表



[[原创\]反调试技术总结](https://bbs.pediy.com/thread-225740.htm)



修复导入表脚本

```
$ArrayPtr = 475000    //开始地址
$ArrayEnd = 475120    //结束地址
 
Loop:
 
cmp dword:[$ArrayPtr], 0    // 跳过模块空隙
je Next
 
EIP = dword:[$ArrayPtr]
RunToParty 1                // 执行到系统模块断下
dword:[$ArrayPtr] = EIP     // 取当前地址
 
Next:
 
$ArrayPtr += 4              // 指向下一块地址
cmp $ArrayPtr, $ArrayEnd    // 判断是否结束
jne Loop
ret
```

### 导入表混淆

1.  IAT 表 填的都是导入函数地址,导入函数地址我们可以改成堆里面的地址,堆里面的代码会跳到真正dll真正的导出函数(这样比较简单,用脚本跑一下就可以了)
2.  吧堆里面的代码用混淆工具混淆一下,换成混淆后的代码
3.  把每个导出函数的前几条指令抠出来,放到堆里面,顺便混淆(对抗脚本)
4.  找一些api,把这些api整个导出来,放到堆里面,执行这api,帮它做一点重定位(如还能破解就把api作膨胀)



#### 把导入表放入堆

可以使用   push   ret   ,但是这样太明显了

可以稍微混淆一下

push     原地址 -  数值

add      dword  ptr[esp] ,数值

 retn



对应汇编代码:

 //偏移+地址 = 真正的api地址

unsigned char code1[13] = {

​        0x68, 

​        0x20, 0x00, 0x40, 0x00, //地址

​        0x81, 0x04, 0x24, 

​        0x00, 0x10, 0x00, 0x00,//偏移

​        0xC3

};



或者



1  call   下条指令的地址

2  pop   eax

3  jmp   要执行代码地址  (指令6的代码地址)

4  jmp   要执行代码地址   (指令6的代码地址)

5  push 16

6  push  dword ptr[eax+3]      //  eax + 3 就是   jmp   要执行代码地址   3 是2 + 3指令长度

7  retn



对应汇编代码:

unsigned char code2[] = {

​        0xE8, 0x00, 0x00, 0x00, 0x00, 0x58, 0xEB, 0x04, 

​        0xEB, 0x02, 0x6A, 0x16,    //地址

​        0xFF, 0x60, 0x03,

​        0xC3, 

​        0xC3, 0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3

};







### 完整源码

#### sehllcode.h

```
#pragma once
#include<windows.h>

#include <compressapi.h>
#pragma comment(lib, "Cabinet.lib")


typedef  FARPROC(WINAPI* PFN_GetProcAddress)(
    _In_ HMODULE hModule,
    _In_ LPCSTR lpProcName
);

typedef  FARPROC(WINAPI* PFN_LoadLibraryA)(
    _In_ LPCSTR lpLibFileName
);

typedef  BOOL(WINAPI* PFN_CreateDecompressor)(
    DWORD   Algorithm,
    PCOMPRESS_ALLOCATION_ROUTINES AllocationRoutines,
    PDECOMPRESSOR_HANDLE   DecompressorHandle
 );


typedef  BOOL(WINAPI* PFN_Decompress)(
    DECOMPRESSOR_HANDLE DecompressorHandle,
    LPCVOID             CompressedData,
    SIZE_T              CompressedDataSize,
    PVOID               UncompressedBuffer,
    SIZE_T              UncompressedBufferSize,
    PSIZE_T             UncompressedDataSize
 );


typedef  LPCVOID(WINAPI* PFN_VirtualAlloc)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );


typedef  BOOL(WINAPI* PFN_VirtualProtect)(
    _In_  LPVOID lpAddress,
    _In_  SIZE_T dwSize,
    _In_  DWORD flNewProtect,
    _Out_ PDWORD lpflOldProtect
    );

struct  EnvironMent 
{
    PFN_GetProcAddress      pfnGetProcAddress;
    PFN_LoadLibraryA    pfnLoadLibraryA;
    PFN_CreateDecompressor   pfnCreateDecompressor;
    PFN_Decompress      pfnDecompress;
    PFN_VirtualAlloc    pfnVirtualAlloc;
    PFN_VirtualProtect  pfnVirtualProtect;
};

void initEnvironment(EnvironMent* pEnv);
HMODULE GetKernel32();
HMODULE GetModuleBase();
void* MyGetProcAddress(HMODULE hMod, LPCSTR lpFunName);
DWORD MyLoadLibrary(LPBYTE pPEBuff, EnvironMent* pEnv);
```

ShellCode.cpp

```

#include "ShellCode.h"
#include <memory.h>


void Entry() {

    EnvironMent env;
    initEnvironment(&env);
    //获取模块基址
    LPBYTE pImBase = (LPBYTE)GetModuleBase();
    //定位到节表
    auto pDosHdr = (PIMAGE_DOS_HEADER)pImBase;                                        //DOS头
    auto pNtHdr = (PIMAGE_NT_HEADERS32)((DWORD)pImBase + pDosHdr->e_lfanew);        //NT头
    auto pSecHdr = (PIMAGE_SECTION_HEADER)((DWORD)&pNtHdr->OptionalHeader + (pNtHdr->FileHeader.SizeOfOptionalHeader));
    //获取压缩数据
    LPBYTE pComData = pImBase + pSecHdr[1].VirtualAddress;
    //解压缩

    DECOMPRESSOR_HANDLE hDecompressor = NULL;
    BOOL bSuccess = env.pfnCreateDecompressor(
        COMPRESS_ALGORITHM_XPRESS_HUFF, //  Compression Algorithm
        NULL,                           //  Optional allocation routine
        &hDecompressor);

    DWORD m_dwComSize = pSecHdr[1].PointerToRelocations;   //压缩后的大小
    DWORD m_dwDecomSize = pSecHdr[1].PointerToLinenumbers; //解压后的大小

    LPBYTE pPEBuff = (LPBYTE)env.pfnVirtualAlloc(NULL, m_dwDecomSize, MEM_COMMIT, PAGE_READWRITE);
    DWORD  DecompressedBufferSize = 0;
    bSuccess = env.pfnDecompress(
        hDecompressor,                //句柄
        pComData,                     //压缩数据
        m_dwComSize,                  //压缩数据大小
        pPEBuff,                      //解压缩缓冲区
        m_dwDecomSize,                //解压缩缓冲区大小
        &DecompressedBufferSize);     //
   //LoadPE
    DWORD dwOpe = MyLoadLibrary(pPEBuff, &env);
    __asm jmp  dwOpe;

}


void initEnvironment(EnvironMent* pEnv)
{

    //获取 Kernel32 的地址
    HMODULE hKer = GetKernel32();

    //获取 GetProcAddress 地址
    char szGetProcAddress[] = { 'G','e','t','P','r','o','c','A','d','d','r','e','s','s','\0' };
    pEnv->pfnGetProcAddress = (PFN_GetProcAddress)MyGetProcAddress(hKer, szGetProcAddress);

    //获取 LoadLibrary地址
    char szLoadlibrary[] = { 'L','o','a','d','L','i','b','r','a','r','y','A','\0' };
    pEnv->pfnLoadLibraryA = (PFN_LoadLibraryA)pEnv->pfnGetProcAddress(hKer, szLoadlibrary);

    //获取 VirtualAlloc 地址
    char szVirtualAlloc[] = { 'V','i','r','t','u','a','l','A','l','l','o','c','\0' };
    pEnv->pfnVirtualAlloc = (PFN_VirtualAlloc)pEnv->pfnGetProcAddress(hKer, szVirtualAlloc);

    //获取 VirtualProtect 地址
    char szVirtualProtect[] = { 'V','i','r','t','u','a','l','P','r','o','t','e','c','t','\0' };
    pEnv->pfnVirtualProtect = (PFN_VirtualProtect)pEnv->pfnGetProcAddress(hKer, szVirtualProtect);

    //获取 Cabinet.lib 地址
    char szCab[] = { 'C','a','b','i', 'n','e','t','\0' };
    HMODULE hCab = (HMODULE)pEnv->pfnLoadLibraryA(szCab);

    //获取 CreateDecompressor 地址
    char szCreateDecompressor[] = { 'C','r','e','a','t','e','D','e','c','o','m','p','r','e','s','s','o','r','\0' };
    pEnv->pfnCreateDecompressor = (PFN_CreateDecompressor)pEnv->pfnGetProcAddress(hCab, szCreateDecompressor);
    //获取 Decompress 地址
    char szDecompress[] = { 'D','e','c','o','m','p','r','e','s','s','\0' };
    pEnv->pfnDecompress = (PFN_Decompress)pEnv->pfnGetProcAddress(hCab, szDecompress);


}



//获取Kernel32地址
HMODULE GetKernel32()
{
    HMODULE hKer = NULL;
    __asm
    {
        mov     eax, dword ptr fs : [0x30]
        mov     eax, dword ptr[eax + 0x0C]
        mov     eax, dword ptr[eax + 0x0C]
        mov     eax, dword ptr[eax]
        mov     eax, dword ptr[eax]
        mov     eax, dword ptr[eax + 0x18]
        mov hKer, eax
    }
    return hKer;
}
//获取模块基址
HMODULE GetModuleBase()
{
    HMODULE hKer = NULL;
    __asm
    {
        mov     eax, dword ptr fs : [0x30]
        mov     eax, dword ptr[eax + 0x0C]
        mov     eax, dword ptr[eax + 0x0C]
        mov     eax, dword ptr[eax + 0x18]
        mov hKer, eax
    }
    return hKer;
}

void* MyGetProcAddress(HMODULE hMod, LPCSTR lpFunName)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hMod;                        //DOS头
    PIMAGE_NT_HEADERS32 pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)hMod + pDosHeader->e_lfanew);      //NT头
    PIMAGE_DATA_DIRECTORY pExportDirectory = &pNtHeader->OptionalHeader.DataDirectory[0];        //导出表数据目录
    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hMod + pExportDirectory->VirtualAddress);
    if ((DWORD)lpFunName > 0xffff)
    {
        //按照名称查找
        for (DWORD i = 0; i < pExport->NumberOfNames; i++)
        {
            char* pName = (char*)(*(DWORD*)((DWORD)hMod + pExport->AddressOfNames + i * 4) + (DWORD)hMod);
            if (strcmp(lpFunName, pName) == 0)
            {
                DWORD dwOrdinals = *(WORD*)((DWORD)hMod + pExport->AddressOfNameOrdinals + i * 2);
                return (void*)(*(DWORD*)((DWORD)hMod + pExport->AddressOfFunctions + dwOrdinals * 4) + (DWORD)hMod);
            }
        }
        return 0;
    }
    else
    {
        //按照序号查找
        DWORD dwOrdinals = (DWORD)lpFunName - pExport->Base;
        if (dwOrdinals >= pExport->NumberOfFunctions)
        {
            return 0;
        }
        return (void*)(*(DWORD*)((DWORD)hMod + pExport->AddressOfFunctions + dwOrdinals * 4) + (DWORD)hMod);
    }
    return 0;
}


void* __cdecl MyMemcpy(void* dst, const void* src, size_t count) {

    void* ret = dst;

    while (count--) {
        *(char*)dst = *(char*)src;
        dst = (char*)dst + 1;
        src = (char*)src + 1;
    }
    return (ret);
}

int __cdecl Mymemcmp(const void* buf1, const void* buf2, size_t count)
{
    if (!count)
        return(0);

    while (--count && *(char*)buf1 == *(char*)buf2) {
        buf1 = (char*)buf1 + 1;
        buf2 = (char*)buf2 + 1;
    }

    return(*((unsigned char*)buf1) - *((unsigned char*)buf2));
}

void* __cdecl Mymemset(void* dst, int val, size_t count)
{
    void* start = dst;
    while (count--) {
        *(char*)dst = (char)val;
        dst = (char*)dst + 1;
    }
    return(start);
}
//输入RVA，参数为 基址、NT头，返回值是所属节表指针
PIMAGE_SECTION_HEADER GetSectionHeader(DWORD RVA, PIMAGE_NT_HEADERS pNtHeader)
{
    PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader);
    DWORD dwNumberOfSections = pNtHeader->FileHeader.NumberOfSections;
    for (DWORD i = 0; i < dwNumberOfSections; i++)
    {
        if (RVA >= pSectionHeader->VirtualAddress && RVA < pSectionHeader->VirtualAddress + pSectionHeader->Misc.VirtualSize)
        {
            return pSectionHeader;
        }
        pSectionHeader++;
    }
    return NULL;
}

#define VirtualProtect pEnv->pfnVirtualProtect
DWORD MyLoadLibrary(LPBYTE pPEBuff, EnvironMent* pEnv)
{

    LPVOID pFileMap = pPEBuff;

    PIMAGE_DOS_HEADER pDosHdr = NULL;
    PIMAGE_NT_HEADERS pNtHdr = NULL;
    PIMAGE_FILE_HEADER pFileHdr = NULL;
    PIMAGE_OPTIONAL_HEADER pOptionalHdr = NULL;
    PIMAGE_SECTION_HEADER pSecHdr = NULL;

    PIMAGE_BASE_RELOCATION pBaseReloc = NULL;
    DWORD dwBaseRelocSize = 0;//重定位表大小
    DWORD dwReadRelocSize = 0;//已读重定位表大小

    DWORD dwNumberOfSections = 0;
    DWORD dwFileHeaderSize = 0;
    DWORD dwImageSize = 0;
    DWORD dwEntry = 0;
    DWORD dwOldProtect = 0;

    DWORD dwRelocBase = 0;//重定位基址


    //1. 获取DOS头
    pDosHdr = (PIMAGE_DOS_HEADER)pFileMap;
    //2. 获取NT头
    pNtHdr = (PIMAGE_NT_HEADERS)((char*)pDosHdr + pDosHdr->e_lfanew);
    //3. 获取文件头 和 可选头
    pFileHdr = &pNtHdr->FileHeader;
    pOptionalHdr = &pNtHdr->OptionalHeader;

    //获取文件头大小 和 内存大小
    dwFileHeaderSize = pOptionalHdr->SizeOfHeaders;
    dwImageSize = pOptionalHdr->SizeOfImage;

    //获取数据目录数据
    pBaseReloc = (PIMAGE_BASE_RELOCATION)pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    dwBaseRelocSize = pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

    HMODULE hMod = GetModuleBase();
    dwRelocBase = ((DWORD)hMod - pOptionalHdr->ImageBase);
    //4. 获取节表数量 和 首地址
    dwNumberOfSections = pFileHdr->NumberOfSections;
    pSecHdr = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHdr + pFileHdr->SizeOfOptionalHeader);
    //5. 获取基址 和 OEP
    dwEntry = (DWORD)hMod + pOptionalHdr->AddressOfEntryPoint;


    //拷贝文件头
    //修改内存属性为 可读可写可执行
    VirtualProtect((LPVOID)hMod, dwFileHeaderSize, PAGE_EXECUTE_READWRITE, &dwOldProtect);
    MyMemcpy((LPVOID)hMod, pDosHdr, dwFileHeaderSize);
    VirtualProtect((LPVOID)hMod, dwFileHeaderSize, dwOldProtect, &dwOldProtect);

    //拷贝节区
    for (int i = 0; i < dwNumberOfSections; i++)
    {
        PIMAGE_SECTION_HEADER pSection = pSecHdr + i;
        LPVOID dwDest = (char*)hMod + pSection->VirtualAddress;
        LPVOID dwSrc = (char*)pFileMap + pSection->PointerToRawData;
        //拷贝内存
        VirtualProtect(dwDest, pSection->SizeOfRawData, PAGE_EXECUTE_READWRITE, &dwOldProtect);
        MyMemcpy(dwDest, dwSrc, pSection->SizeOfRawData);
        VirtualProtect(dwDest, pSection->SizeOfRawData, dwOldProtect, &dwOldProtect);
    }
    //帮忙导入IAT
    //空导入表信息
    IMAGE_IMPORT_DESCRIPTOR ZeroIID = { 0 };

    //获取导入表地址
    DWORD dwIID = pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    //寻找符合的节并计算出VA地址
    BOOL bRet = FALSE;
    DWORD dwDiff = GetSectionHeader(dwIID, pNtHdr)->VirtualAddress - GetSectionHeader(dwIID, pNtHdr)->PointerToRawData;
    dwIID = dwIID - dwDiff;

    PIMAGE_IMPORT_DESCRIPTOR pItem = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileMap + dwIID);


    //放置混淆代码的缓冲区
    LPBYTE pIATBuf = (LPBYTE)pEnv->pfnVirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    DWORD dwIATBufOff = 0;

    while (true)
    {
        if (pItem->Name == NULL || pItem->FirstThunk == NULL)
        {
            //遍历结束
            break;
        }
        //加载DLL
        HMODULE hDll = (HMODULE)pEnv->pfnLoadLibraryA((LPCSTR)((DWORD)pFileMap + pItem->Name - dwDiff));
        if (hDll == nullptr)
        {
            break;
        }
        //判断OriginalFirstThunk（INT）是否存在
        PDWORD pINT = (PDWORD)pItem->FirstThunk;
        if (pItem->OriginalFirstThunk != NULL)
        {
            pINT = (PDWORD)pItem->OriginalFirstThunk;
        }
        pINT = (PDWORD)((DWORD)pFileMap + (DWORD)pINT - dwDiff);
        DWORD dwIATaddr = pItem->FirstThunk + (DWORD)hMod;

        //遍历导入名称表
        while (*pINT != NULL)
        {
            //判断是否是序号
            DWORD dwFuncAddr = 0;
            if (*pINT & 0x80000000)
            {
                //序号导入
                dwFuncAddr = (DWORD)pEnv->pfnGetProcAddress(hDll, (LPCSTR)LOWORD(*pINT));
            }
            else
            {
                dwFuncAddr = (DWORD)pEnv->pfnGetProcAddress(hDll, (LPCSTR)((DWORD)pFileMap + sizeof WORD + *(PDWORD)pINT - dwDiff));
            }
            VirtualProtect((LPVOID)dwIATaddr, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect);
            // *(DWORD*)dwIATaddr = dwFuncAddr;          //填入IAT

              //偏移+地址 = 真正的api地址
            unsigned char code1[13] = {
              0x68,
              0x20, 0x00, 0x40, 0x00, //地址
              0x81, 0x04, 0x24,
              0x00, 0x10, 0x00, 0x00,//偏移
              0xC3
            };

            //抽出一部分指令的
            unsigned char code2[] = {
              0xE8, 0x00, 0x00, 0x00, 0x00, 0x58, 0xEB, 0x04,
              0xEB, 0x02, 0x6A, 0x16, //地址
              0xFF, 0x60, 0x03, 0xC3,
              0xC3, 0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3
            };

            //没有抽出一部分指令的
            unsigned char code3[] = {
              0xE8, 0x00, 0x00, 0x00, 0x00, 0x58, 0xEB, 0x04,
              0xEB, 0x02, 0x6A, 0x16, //地址
              0x8b, 0xff, 0x55, 0x8b, 0xec,
              0xFF, 0x60, 0x03, 0xC3,
              0xC3
            };

            //api函数的部分指令
            // mov edi,edi      push ebp        mov ebp ,esp
            unsigned char hdr[] = { 0x8b, 0xff, 0x55, 0x8b, 0xec };
            //*(DWORD*)dwIATaddr = dwFuncAddr; 填入IAT
            DWORD dwRand = dwFuncAddr;
            if ((dwRand >> 4) % 2 == 0)    //产生一个随机数0 或 1
            {

                *(DWORD*)dwIATaddr = (DWORD)(pIATBuf + dwIATBufOff);
                *(LPDWORD)(code1 + 8) = dwFuncAddr % 0x10000;   //修改偏移
                *(LPDWORD)(code1 + 1) = (dwFuncAddr / 0x10000) * 0x10000;   //修改地址
        
                MyMemcpy(pIATBuf + dwIATBufOff, code1, sizeof(code1));
                dwIATBufOff += sizeof(code1);
            }
            else
            {
                
                *(DWORD*)dwIATaddr = (DWORD)(pIATBuf + dwIATBufOff);
                if (Mymemcmp((void*)dwFuncAddr, hdr, sizeof(hdr)) == 0)  //判断函数有没有提取出来的指令
                {
                    *(LPDWORD)(code3 + 8) = dwFuncAddr + 5;    //修改地址
                    MyMemcpy(pIATBuf + dwIATBufOff, code3, sizeof(code3));
                    dwIATBufOff += sizeof(code3);
                }
                else
                {
                    *(LPDWORD)(code2 + 8) = dwFuncAddr;      //修改地址
                    MyMemcpy(pIATBuf + dwIATBufOff, code2, sizeof(code2));
                    dwIATBufOff += sizeof(code2);
                }
            }

            VirtualProtect((LPVOID)dwIATaddr, 1, dwOldProtect, &dwOldProtect);
            pINT++;
            dwIATaddr += 4;
        }

        pItem++;
    }

    //修复重定位
    if (pBaseReloc == NULL)
    {
        return dwEntry;
    }
    PIMAGE_SECTION_HEADER pBaseSecHdr = GetSectionHeader((DWORD)pBaseReloc, pNtHdr);
    pBaseReloc = (IMAGE_BASE_RELOCATION*)((DWORD)pFileMap + (DWORD)pBaseReloc - pBaseSecHdr->VirtualAddress + pBaseSecHdr->PointerToRawData);

    for (; dwReadRelocSize < dwBaseRelocSize;)
    {

        DWORD dwPageOff = pBaseReloc->VirtualAddress;

        LPWORD pRelocData = (LPWORD)((DWORD)pBaseReloc + sizeof(IMAGE_BASE_RELOCATION));

        DWORD dwItemCount = (pBaseReloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        //遍历数据
        for (size_t i = 0; i < dwItemCount; i++)
        {
            WORD wData = pRelocData[i];
            if (wData & 0x3000)
            {
                //如果是需要重定位的
                DWORD dwAddr = (DWORD)hMod + dwPageOff + (wData & 0x0FFF);
                *(DWORD*)dwAddr += dwRelocBase;
            }
        }

        dwReadRelocSize += pBaseReloc->SizeOfBlock;
        pBaseReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseReloc + pBaseReloc->SizeOfBlock);
    }

    return dwEntry;
}


```

#### 加壳代码



CPacker.h

```
#pragma once
class CPacker
{

public:
    bool Pack(CString strSrc, CString strDst);    //实现加壳

private:
    DWORD GetAlign(DWORD dwValue, DWORD dwAlign);

    //解析原PE
private:
    HANDLE m_hFile;          
    HANDLE m_hFileMap;
    LPBYTE m_pSrcPe;                  
    DWORD m_dwSrcPeSize;              //原PE数据大小

    PIMAGE_DOS_HEADER m_pDosHdr;      //dos头
    PIMAGE_NT_HEADERS m_pNtHdr;       //nt头
    PIMAGE_SECTION_HEADER m_pSecHdr;  //节表

    bool AnalyzePe(CString strSrc);   //解析PE数据

    //对原PE进行压缩, 获取压缩数据
private:
    LPBYTE m_pComData;//压缩后的数据缓冲区
    DWORD m_dwComSize;//压缩后的数据的大小
    bool GetCompressData();

    //获取解压缩代码 
private:
    LPBYTE m_pCode;      //壳代码(解压缩代码)
    DWORD m_dwCodeSize;  //代码大小
    bool GetCode();

    //合成新PE
private:
    LPBYTE m_pComSec;     //数据节
    DWORD m_dwComSecSize; //数据节大小
    void GetComSec();

private:
    LPBYTE m_pCodeSec;     //代码节
    DWORD m_dwCodeSecSize; //代码节大小
    void GetCodeSec();

private:
    IMAGE_SECTION_HEADER m_newSecHdr[3];   //新的节表
    void GetNewSectionHeaders();

private:
    LPBYTE m_pNewPeHdr;      //新的PE头
    DWORD m_dwNewPeHdrSize;  //新的PE头大小
    void GetNewPeHdr();

    //写入文件
private:
    bool WriteNewPe(CString	strNewPe);
};

```





CPacker.cpp

```
#include "pch.h"
#include "CPacker.h"

#include <compressapi.h>
#pragma comment(lib, "Cabinet.lib")

bool CPacker::Pack(CString strSrc, CString strDst)
{

    //解析原PE
    if (!AnalyzePe(strSrc)) {
        return false;
    }

    //对原PE进行压缩,获取压缩数据
    if (!GetCompressData()) {
        return false;
    }
    

    //获取解压缩代码
    if (!GetCode()) {
        return false;
    }
    //合成新PE
      //1压缩数据节
    GetComSec();
      //2壳代码节
    GetCodeSec();
      //3构造节表
    GetNewSectionHeaders();
      //4构造PE头
    GetNewPeHdr();

    if (!WriteNewPe(strDst)) {
        return false;
    }

    //写入文件
    return true;
}

DWORD CPacker::GetAlign(DWORD dwValue, DWORD dwAlign)
{

    if (dwValue % dwAlign == 0) {
        return dwValue;
    }
    else
    {
        return  (dwValue / dwAlign + 1) * dwAlign;
    }
    return 0;
}

////解析原PE
bool CPacker::AnalyzePe(CString strSrc)
{

    m_hFile = CreateFile(strSrc,           // open MYFILE.TXT 
        GENERIC_READ,              // open for reading 
        FILE_SHARE_READ,           // share for reading 
        NULL,                      // no security 
        OPEN_EXISTING,             // existing file only 
        FILE_ATTRIBUTE_NORMAL,     // normal file 
        NULL);                     // no attr. template 

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    m_dwSrcPeSize = GetFileSize(m_hFile, NULL);
    // 创建文件映射
    m_hFileMap = CreateFileMapping(m_hFile, 0, PAGE_READONLY, 0, 0, NULL);
    if (m_hFileMap == NULL)
    {
        return false;
    }
    //把内存数据映射进PE数据缓冲区
    m_pSrcPe = (LPBYTE)MapViewOfFile(m_hFileMap, FILE_MAP_READ, 0, 0, 0);
    if (m_pSrcPe == NULL)
    {
        return false;
    }

    m_pDosHdr = (PIMAGE_DOS_HEADER)m_pSrcPe;                                        //DOS头
    m_pNtHdr = (PIMAGE_NT_HEADERS32)((DWORD)m_pSrcPe + m_pDosHdr->e_lfanew);        //NT头
    m_pSecHdr = (PIMAGE_SECTION_HEADER)((DWORD)&m_pNtHdr->OptionalHeader + (m_pNtHdr->FileHeader.SizeOfOptionalHeader));

    //检查格式

    return true;

}

//对原PE进行压缩,获取压缩数据
bool CPacker::GetCompressData()
{
    COMPRESSOR_HANDLE hCompressor;
    BOOL bSuccess = CreateCompressor(
        COMPRESS_ALGORITHM_XPRESS_HUFF, //  Compression Algorithm
        NULL,                           //  Optional allocation routine
        &hCompressor);                   //  Handle

   //获取压缩后数据缓冲区的大小
    //DWORD dwCompressedBufferSize;
    //bSuccess = Compress(
    //    hCompressor,                  //  句柄
    //    m_pSrcPe,                     //  压缩前数据
    //    m_dwSrcPeSize,                //  压缩前大小
    //    NULL,                         //  压缩后的数据缓冲区
    //    0,                            //  压缩后的数据缓冲区大小
    //    &dwCompressedBufferSize);     //  压缩后的数据大小


    //申请缓冲区
    m_pComData = new BYTE[m_dwSrcPeSize];
    if (m_pComData == nullptr)
    {
        return false;
    }
    //压缩数据
    bSuccess = Compress(           
        hCompressor,              //  句柄 
        m_pSrcPe,                 //  压缩前数据
        m_dwSrcPeSize,            //  压缩前大小
        m_pComData,               //  压缩后的数据缓冲区
        m_dwSrcPeSize,            //  压缩后的数据缓冲区大小
        &m_dwComSize);            //  压缩后的数据大小
    if (!bSuccess)
    {
        return false;
    }

    CloseCompressor(hCompressor);
    return true;
}

//壳代码(解压缩算法)
unsigned char g_Codedata[] = {
  0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x48, 0x8D, 0x4D, 0xB8, 0xE8, 0xC2, 0x00, 0x00, 0x00, 0xE8, 0x7D,
  0x02, 0x00, 0x00, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x89, 0x45, 0xE8, 0x8B, 0x4D, 0xE8, 0x8B,
  0x55, 0xFC, 0x03, 0x51, 0x3C, 0x89, 0x55, 0xF4, 0x8B, 0x45, 0xF4, 0x0F, 0xB7, 0x48, 0x14, 0x8B,
  0x55, 0xF4, 0x8D, 0x44, 0x0A, 0x18, 0x89, 0x45, 0xF8, 0xB9, 0x28, 0x00, 0x00, 0x00, 0xC1, 0xE1,
  0x00, 0x8B, 0x55, 0xF8, 0x8B, 0x45, 0xFC, 0x03, 0x44, 0x0A, 0x0C, 0x89, 0x45, 0xDC, 0xB9, 0x28,
  0x00, 0x00, 0x00, 0xC1, 0xE1, 0x00, 0x8B, 0x55, 0xF8, 0x8B, 0x44, 0x0A, 0x18, 0x89, 0x45, 0xE0,
  0xB9, 0x28, 0x00, 0x00, 0x00, 0xC1, 0xE1, 0x00, 0x8B, 0x55, 0xF8, 0x8B, 0x44, 0x0A, 0x1C, 0x89,
  0x45, 0xF0, 0x6A, 0x04, 0x68, 0x00, 0x10, 0x00, 0x00, 0x8B, 0x4D, 0xF0, 0x51, 0x6A, 0x00, 0xFF,
  0x55, 0xC8, 0x89, 0x45, 0xEC, 0x8D, 0x55, 0xD8, 0x52, 0x6A, 0x00, 0x6A, 0x04, 0xFF, 0x55, 0xC0,
  0x89, 0x45, 0xD4, 0xC7, 0x45, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x45, 0xE4, 0x50, 0x8B, 0x4D,
  0xF0, 0x51, 0x8B, 0x55, 0xEC, 0x52, 0x8B, 0x45, 0xE0, 0x50, 0x8B, 0x4D, 0xDC, 0x51, 0x8B, 0x55,
  0xD8, 0x52, 0xFF, 0x55, 0xC4, 0x89, 0x45, 0xD4, 0x8D, 0x55, 0xB8, 0x8B, 0x4D, 0xEC, 0xE8, 0xED,
  0x01, 0x00, 0x00, 0x89, 0x45, 0xD0, 0xFF, 0x65, 0xD0, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC,
  0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x68, 0x53, 0x8B, 0xD9, 0x56, 0x89, 0x5D, 0xF0, 0x64, 0xA1, 0x30,
  0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x0C, 0x8B, 0x00, 0x8B, 0x00, 0x8B, 0x40, 0x18,
  0x89, 0x45, 0xFC, 0x8B, 0x75, 0xFC, 0x33, 0xD2, 0x8B, 0x46, 0x3C, 0x39, 0x54, 0x30, 0x7C, 0x0F,
  0x84, 0x9E, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x30, 0x78, 0x85, 0xC0, 0x0F, 0x84, 0x92, 0x00, 0x00,
  0x00, 0x8B, 0x4C, 0x30, 0x24, 0x8B, 0x5C, 0x30, 0x20, 0x03, 0xCE, 0x89, 0x4D, 0xF8, 0x03, 0xDE,
  0x8B, 0x4C, 0x30, 0x1C, 0x03, 0xCE, 0x57, 0x8B, 0x7C, 0x30, 0x18, 0x89, 0x4D, 0xF4, 0x33, 0xC9,
  0x4F, 0x8B, 0x04, 0x8B, 0x03, 0xC6, 0x80, 0x38, 0x47, 0x75, 0x4E, 0x80, 0x78, 0x01, 0x65, 0x75,
  0x48, 0x80, 0x78, 0x02, 0x74, 0x75, 0x42, 0x80, 0x78, 0x03, 0x50, 0x75, 0x3C, 0x80, 0x78, 0x04,
  0x72, 0x75, 0x36, 0x80, 0x78, 0x05, 0x6F, 0x75, 0x30, 0x80, 0x78, 0x06, 0x63, 0x75, 0x2A, 0x80,
  0x78, 0x07, 0x41, 0x75, 0x24, 0x80, 0x78, 0x08, 0x64, 0x75, 0x1E, 0x80, 0x78, 0x09, 0x64, 0x75,
  0x18, 0x80, 0x78, 0x0A, 0x72, 0x75, 0x12, 0x80, 0x78, 0x0B, 0x65, 0x75, 0x0C, 0x80, 0x78, 0x0C,
  0x73, 0x75, 0x06, 0x80, 0x78, 0x0D, 0x73, 0x74, 0x07, 0x41, 0x3B, 0xCF, 0x76, 0xA3, 0xEB, 0x0F,
  0x8B, 0x45, 0xF8, 0x8B, 0x55, 0xF4, 0x0F, 0xB7, 0x04, 0x48, 0x8B, 0x14, 0x82, 0x03, 0xD6, 0x8B,
  0x5D, 0xF0, 0x5F, 0x8D, 0x45, 0xCC, 0x89, 0x13, 0x50, 0x56, 0xC7, 0x45, 0xCC, 0x4C, 0x6F, 0x61,
  0x64, 0xC7, 0x45, 0xD0, 0x4C, 0x69, 0x62, 0x72, 0xC7, 0x45, 0xD4, 0x61, 0x72, 0x79, 0x41, 0xC6,
  0x45, 0xD8, 0x00, 0xFF, 0xD2, 0x89, 0x43, 0x04, 0x8D, 0x45, 0xBC, 0x50, 0x8B, 0x03, 0x56, 0xC7,
  0x45, 0xBC, 0x56, 0x69, 0x72, 0x74, 0xC7, 0x45, 0xC0, 0x75, 0x61, 0x6C, 0x41, 0xC7, 0x45, 0xC4,
  0x6C, 0x6C, 0x6F, 0x63, 0xC6, 0x45, 0xC8, 0x00, 0xFF, 0xD0, 0x89, 0x43, 0x10, 0x8D, 0x45, 0xAC,
  0x50, 0x8B, 0x03, 0x56, 0xC7, 0x45, 0xAC, 0x56, 0x69, 0x72, 0x74, 0xC7, 0x45, 0xB0, 0x75, 0x61,
  0x6C, 0x50, 0xC7, 0x45, 0xB4, 0x72, 0x6F, 0x74, 0x65, 0x66, 0xC7, 0x45, 0xB8, 0x63, 0x74, 0xC6,
  0x45, 0xBA, 0x00, 0xFF, 0xD0, 0x89, 0x43, 0x14, 0x8D, 0x45, 0xE8, 0x50, 0x8B, 0x43, 0x04, 0xC7,
  0x45, 0xE8, 0x43, 0x61, 0x62, 0x69, 0xC7, 0x45, 0xEC, 0x6E, 0x65, 0x74, 0x00, 0xFF, 0xD0, 0x8B,
  0xF0, 0xC7, 0x45, 0x98, 0x43, 0x72, 0x65, 0x61, 0x8D, 0x45, 0x98, 0xC7, 0x45, 0x9C, 0x74, 0x65,
  0x44, 0x65, 0x50, 0x8B, 0x03, 0x56, 0xC7, 0x45, 0xA0, 0x63, 0x6F, 0x6D, 0x70, 0xC7, 0x45, 0xA4,
  0x72, 0x65, 0x73, 0x73, 0x66, 0xC7, 0x45, 0xA8, 0x6F, 0x72, 0xC6, 0x45, 0xAA, 0x00, 0xFF, 0xD0,
  0x89, 0x43, 0x08, 0x8D, 0x45, 0xDC, 0x50, 0x8B, 0x03, 0x56, 0xC7, 0x45, 0xDC, 0x44, 0x65, 0x63,
  0x6F, 0xC7, 0x45, 0xE0, 0x6D, 0x70, 0x72, 0x65, 0x66, 0xC7, 0x45, 0xE4, 0x73, 0x73, 0xC6, 0x45,
  0xE6, 0x00, 0xFF, 0xD0, 0x5E, 0x89, 0x43, 0x0C, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC,
  0x55, 0x8B, 0xEC, 0x51, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x0C,
  0x8B, 0x40, 0x18, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC,
  0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x94, 0x00, 0x00, 0x00, 0x8B, 0xC1, 0xC7, 0x45, 0xF8, 0x00, 0x00,
  0x00, 0x00, 0x53, 0x56, 0x89, 0x45, 0xF0, 0x8B, 0x48, 0x3C, 0x03, 0xC8, 0x89, 0x55, 0xF4, 0x8B,
  0x81, 0xA0, 0x00, 0x00, 0x00, 0x8D, 0x71, 0x18, 0x8B, 0x5E, 0x3C, 0x89, 0x85, 0x74, 0xFF, 0xFF,
  0xFF, 0x8B, 0x86, 0x8C, 0x00, 0x00, 0x00, 0x57, 0xC7, 0x45, 0x84, 0x00, 0x00, 0x00, 0x00, 0x89,
  0x4D, 0x88, 0x89, 0x45, 0x80, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40,
  0x0C, 0x8B, 0x40, 0x18, 0x89, 0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x8B, 0x85, 0x7C, 0xFF, 0xFF, 0xFF,
  0x0F, 0xB7, 0x79, 0x06, 0x89, 0x45, 0xEC, 0x2B, 0x46, 0x1C, 0x89, 0x85, 0x70, 0xFF, 0xFF, 0xFF,
  0x0F, 0xB7, 0x41, 0x14, 0x03, 0xC6, 0x89, 0x7D, 0xE8, 0x89, 0x45, 0xE0, 0x8B, 0x46, 0x10, 0x8B,
  0x75, 0xEC, 0x03, 0xC6, 0x89, 0x45, 0x90, 0x8D, 0x45, 0xF8, 0x50, 0x8B, 0x42, 0x14, 0x6A, 0x40,
  0x53, 0x56, 0xFF, 0xD0, 0x8B, 0x45, 0xF0, 0x8B, 0xD3, 0x8B, 0xC8, 0x85, 0xDB, 0x74, 0x13, 0x2B,
  0xF0, 0x8A, 0x01, 0x8D, 0x49, 0x01, 0x88, 0x44, 0x0E, 0xFF, 0x83, 0xEA, 0x01, 0x75, 0xF2, 0x8B,
  0x75, 0xEC, 0x8B, 0x4D, 0xF4, 0x8D, 0x45, 0xF8, 0x50, 0xFF, 0x75, 0xF8, 0x8B, 0x41, 0x14, 0x53,
  0x56, 0xFF, 0xD0, 0x85, 0xFF, 0x74, 0x5C, 0x8B, 0x7D, 0xE0, 0x83, 0xC7, 0x10, 0x8D, 0x49, 0x00,
  0x8B, 0x5F, 0xFC, 0x8D, 0x45, 0xF8, 0x50, 0x8B, 0x45, 0xF4, 0x03, 0xDE, 0x8B, 0x77, 0x04, 0x03,
  0x75, 0xF0, 0x6A, 0x40, 0xFF, 0x37, 0x8B, 0x40, 0x14, 0x53, 0xFF, 0xD0, 0x8B, 0x0F, 0x85, 0xC9,
  0x74, 0x14, 0x8B, 0xD3, 0x2B, 0xD6, 0x8A, 0x06, 0x8D, 0x76, 0x01, 0x88, 0x44, 0x32, 0xFF, 0x83,
  0xE9, 0x01, 0x75, 0xF2, 0x8B, 0x0F, 0x8D, 0x45, 0xF8, 0x50, 0xFF, 0x75, 0xF8, 0x8B, 0x45, 0xF4,
  0x51, 0x53, 0x8B, 0x40, 0x14, 0xFF, 0xD0, 0x8B, 0x75, 0xEC, 0x83, 0xC7, 0x28, 0x83, 0x6D, 0xE8,
  0x01, 0x75, 0xAD, 0x8B, 0x5D, 0x88, 0x33, 0xFF, 0x8B, 0x83, 0x80, 0x00, 0x00, 0x00, 0x8D, 0x4B,
  0x18, 0x89, 0x45, 0xFC, 0x0F, 0xB7, 0x43, 0x14, 0x0F, 0xB7, 0x5B, 0x06, 0x03, 0xC8, 0x8B, 0xD1,
  0x85, 0xDB, 0x74, 0x1F, 0x8B, 0x45, 0xFC, 0x8B, 0x72, 0x0C, 0x3B, 0xC6, 0x72, 0x0D, 0x8B, 0x42,
  0x08, 0x03, 0xC6, 0x39, 0x45, 0xFC, 0x72, 0x0D, 0x8B, 0x45, 0xFC, 0x47, 0x83, 0xC2, 0x28, 0x3B,
  0xFB, 0x72, 0xE4, 0x33, 0xD2, 0x33, 0xF6, 0x85, 0xDB, 0x74, 0x21, 0x8B, 0x45, 0xFC, 0x8B, 0xFF,
  0x8B, 0x79, 0x0C, 0x3B, 0xC7, 0x72, 0x0D, 0x8B, 0x41, 0x08, 0x03, 0xC7, 0x39, 0x45, 0xFC, 0x72,
  0x0D, 0x8B, 0x45, 0xFC, 0x46, 0x83, 0xC1, 0x28, 0x3B, 0xF3, 0x72, 0xE4, 0x33, 0xC9, 0x8B, 0x42,
  0x0C, 0x2B, 0x41, 0x14, 0x8B, 0x75, 0xF4, 0x6A, 0x40, 0x68, 0x00, 0x10, 0x00, 0x00, 0x68, 0x00,
  0x00, 0x01, 0x00, 0x89, 0x45, 0xE4, 0x8B, 0x46, 0x10, 0x6A, 0x00, 0xFF, 0xD0, 0x8B, 0x5D, 0xFC,
  0x33, 0xFF, 0x8B, 0x4D, 0xE4, 0x2B, 0xD9, 0x8B, 0x55, 0xF0, 0x03, 0xDA, 0x89, 0x85, 0x78, 0xFF,
  0xFF, 0xFF, 0x89, 0x7D, 0xE8, 0x89, 0x5D, 0xFC, 0x8B, 0x43, 0x0C, 0x85, 0xC0, 0x0F, 0x84, 0xEC,
  0x01, 0x00, 0x00, 0xEB, 0x0E, 0xEB, 0x09, 0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00, 0x8B, 0xFF,
  0x8B, 0x55, 0xF0, 0x83, 0x7B, 0x10, 0x00, 0x0F, 0x84, 0xD2, 0x01, 0x00, 0x00, 0x2B, 0xC1, 0x03,
  0xC2, 0x50, 0x8B, 0x46, 0x04, 0xFF, 0xD0, 0x89, 0x45, 0x8C, 0x85, 0xC0, 0x0F, 0x84, 0xBD, 0x01,
  0x00, 0x00, 0x8B, 0x03, 0x8B, 0x4B, 0x10, 0x8B, 0xD1, 0x85, 0xC0, 0x74, 0x02, 0x8B, 0xD0, 0x8B,
  0x45, 0xF0, 0x2B, 0x45, 0xE4, 0x8B, 0x75, 0xEC, 0x03, 0xD0, 0x03, 0xF1, 0x89, 0x55, 0xE0, 0x89,
  0x75, 0x94, 0x8B, 0x02, 0x85, 0xC0, 0x0F, 0x84, 0x7C, 0x01, 0x00, 0x00, 0x8D, 0x64, 0x24, 0x00,
  0x8B, 0x4D, 0xF4, 0x8B, 0x09, 0x85, 0xC0, 0x79, 0x05, 0x0F, 0xB7, 0xC0, 0xEB, 0x0B, 0x8B, 0x55,
  0xF0, 0x2B, 0x45, 0xE4, 0x83, 0xC2, 0x02, 0x03, 0xC2, 0x50, 0xFF, 0x75, 0x8C, 0xFF, 0xD1, 0x8B,
  0xD8, 0x8D, 0x45, 0xF8, 0x50, 0x8B, 0x45, 0xF4, 0x6A, 0x40, 0x6A, 0x01, 0x56, 0x8B, 0x40, 0x14,
  0xFF, 0xD0, 0x03, 0xBD, 0x78, 0xFF, 0xFF, 0xFF, 0xB2, 0xC3, 0xC7, 0x45, 0xC8, 0x68, 0x20, 0x00,
  0x40, 0xC7, 0x45, 0xCC, 0x00, 0x81, 0x04, 0x24, 0xC7, 0x45, 0xD0, 0x00, 0x10, 0x00, 0x00, 0xC7,
  0x45, 0x98, 0xE8, 0x00, 0x00, 0x00, 0xC7, 0x45, 0x9C, 0x00, 0x58, 0xEB, 0x04, 0xC7, 0x45, 0xA4,
  0xFF, 0x60, 0x03, 0xC3, 0xC7, 0x45, 0xA8, 0xC3, 0xC3, 0xC3, 0xC3, 0xC7, 0x45, 0xAC, 0xC3, 0xC3,
  0xC3, 0xC3, 0xC7, 0x45, 0xB0, 0xE8, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xB4, 0x00, 0x58, 0xEB, 0x04,
  0xC7, 0x45, 0xBC, 0x8B, 0xFF, 0x55, 0x8B, 0xC7, 0x45, 0xC0, 0xEC, 0xFF, 0x60, 0x03, 0x66, 0xC7,
  0x45, 0xC4, 0xC3, 0xC3, 0xC7, 0x45, 0xD8, 0x8B, 0xFF, 0x55, 0x8B, 0xC6, 0x45, 0xDC, 0xEC, 0x89,
  0x3E, 0xF6, 0xC3, 0x10, 0x75, 0x24, 0x0F, 0xB7, 0xCB, 0x81, 0xE3, 0x00, 0x00, 0xFF, 0xFF, 0x89,
  0x5D, 0xC9, 0x8B, 0x45, 0xC8, 0x89, 0x07, 0x8B, 0x45, 0xCC, 0x89, 0x47, 0x04, 0xB8, 0x0D, 0x00,
  0x00, 0x00, 0x89, 0x4F, 0x08, 0x88, 0x57, 0x0C, 0xEB, 0x75, 0x8D, 0x55, 0xD8, 0x8B, 0xCB, 0xBE,
  0x04, 0x00, 0x00, 0x00, 0x8A, 0x01, 0x3A, 0x02, 0x75, 0x07, 0x41, 0x42, 0x83, 0xEE, 0x01, 0x75,
  0xF3, 0x0F, 0xB6, 0x09, 0x0F, 0xB6, 0x02, 0x8B, 0x75, 0x94, 0x2B, 0xC8, 0x75, 0x2C, 0x8B, 0x45,
  0xB0, 0x8D, 0x4B, 0x05, 0x89, 0x07, 0x8B, 0x45, 0xB4, 0x89, 0x47, 0x04, 0x8B, 0x45, 0xBC, 0x89,
  0x4F, 0x08, 0x89, 0x47, 0x0C, 0x8B, 0x45, 0xC0, 0x89, 0x47, 0x10, 0x66, 0x8B, 0x45, 0xC4, 0x66,
  0x89, 0x47, 0x14, 0xB8, 0x16, 0x00, 0x00, 0x00, 0xEB, 0x25, 0x8B, 0x45, 0x98, 0x89, 0x07, 0x8B,
  0x45, 0x9C, 0x89, 0x47, 0x04, 0x8B, 0x45, 0xA4, 0x89, 0x5F, 0x08, 0x89, 0x47, 0x0C, 0x8B, 0x45,
  0xA8, 0x89, 0x47, 0x10, 0x8B, 0x45, 0xAC, 0x89, 0x47, 0x14, 0xB8, 0x18, 0x00, 0x00, 0x00, 0x8B,
  0x7D, 0xE8, 0x03, 0xF8, 0x8D, 0x45, 0xF8, 0x50, 0xFF, 0x75, 0xF8, 0x8B, 0x45, 0xF4, 0x6A, 0x01,
  0x56, 0x89, 0x7D, 0xE8, 0x8B, 0x40, 0x14, 0xFF, 0xD0, 0x8B, 0x55, 0xE0, 0x83, 0xC6, 0x04, 0x83,
  0xC2, 0x04, 0x89, 0x75, 0x94, 0x89, 0x55, 0xE0, 0x8B, 0x02, 0x85, 0xC0, 0x0F, 0x85, 0x8E, 0xFE,
  0xFF, 0xFF, 0x8B, 0x5D, 0xFC, 0x89, 0x7D, 0xE8, 0x8B, 0x43, 0x20, 0x83, 0xC3, 0x14, 0x8B, 0x75,
  0xF4, 0x8B, 0x4D, 0xE4, 0x89, 0x5D, 0xFC, 0x85, 0xC0, 0x0F, 0x85, 0x21, 0xFE, 0xFF, 0xFF, 0x8B,
  0x9D, 0x74, 0xFF, 0xFF, 0xFF, 0x85, 0xDB, 0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x8B, 0x55, 0x88,
  0x0F, 0xB7, 0x42, 0x14, 0x8D, 0x4A, 0x18, 0x0F, 0xB7, 0x7A, 0x06, 0x03, 0xC8, 0x33, 0xD2, 0x85,
  0xFF, 0x74, 0x18, 0x8B, 0x71, 0x0C, 0x3B, 0xDE, 0x72, 0x09, 0x8B, 0x41, 0x08, 0x03, 0xC6, 0x3B,
  0xD8, 0x72, 0x0A, 0x42, 0x83, 0xC1, 0x28, 0x3B, 0xD7, 0x72, 0xE8, 0x33, 0xC9, 0x8B, 0x41, 0x14,
  0x2B, 0x41, 0x0C, 0x03, 0x45, 0xF0, 0x03, 0xD8, 0x83, 0x7D, 0x80, 0x00, 0x76, 0x4B, 0x8B, 0x7D,
  0xEC, 0x8B, 0x43, 0x04, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x33, 0x8D, 0x50, 0xF8, 0xD1, 0xEA,
  0x74, 0x28, 0x0F, 0xB7, 0x44, 0x4B, 0x08, 0xA9, 0x00, 0x30, 0x00, 0x00, 0x74, 0x14, 0x25, 0xFF,
  0x0F, 0x00, 0x00, 0x03, 0xC6, 0x03, 0xC7, 0x8B, 0xBD, 0x70, 0xFF, 0xFF, 0xFF, 0x01, 0x38, 0x8B,
  0x7D, 0xEC, 0x41, 0x3B, 0xCA, 0x72, 0xDB, 0x8B, 0x43, 0x04, 0x8B, 0x4D, 0x84, 0x03, 0xD8, 0x03,
  0xC8, 0x89, 0x4D, 0x84, 0x3B, 0x4D, 0x80, 0x72, 0xB8, 0x8B, 0x45, 0x90, 0x5F, 0x5E, 0x5B, 0x8B,
  0xE5, 0x5D, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

bool CPacker::GetCode()
{
    m_dwCodeSize = sizeof(g_Codedata);
    m_pCode = new BYTE[m_dwCodeSize];
    //RtlCopyMemory(m_pCode, g_Codedata, m_dwCodeSize);
    CopyMemory(m_pCode, g_Codedata, m_dwCodeSize);
    return true;
}

void CPacker::GetComSec()
{

    //跟文件对齐值对齐
    m_dwComSecSize = GetAlign(m_dwComSize, m_pNtHdr->OptionalHeader.FileAlignment);
    m_pComSec = new BYTE[m_dwComSecSize];
    ZeroMemory(m_pComSec, m_dwComSecSize);
    //拷贝数据
    CopyMemory(m_pComSec, m_pComData, m_dwComSize);
}

void CPacker::GetCodeSec()
{

    //跟文件对齐值对齐
    m_dwCodeSecSize = GetAlign(m_dwCodeSize, m_pNtHdr->OptionalHeader.FileAlignment);
    m_pCodeSec = new BYTE[m_dwCodeSecSize];
    ZeroMemory(m_pCodeSec, m_dwCodeSecSize);
    //拷贝数据
    CopyMemory(m_pCodeSec, m_pCode, m_dwCodeSize);
}

void CPacker::GetNewSectionHeaders()
{
    ZeroMemory(m_newSecHdr, sizeof(m_newSecHdr));
    //空节
    strcpy((char*)m_newSecHdr[0].Name, ".cr42");
    m_newSecHdr[0].Misc.VirtualSize = m_pNtHdr->OptionalHeader.SizeOfImage;
    m_newSecHdr[0].VirtualAddress = m_pSecHdr[0].VirtualAddress;  //和原先PE第一个内存位置一样
    m_newSecHdr[0].SizeOfRawData = 0;   //空节没有文件大小
    m_newSecHdr[0].PointerToRawData = 0;   
    m_newSecHdr[0].Characteristics = 
        IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ;//内存属性(要往里面写代码所以最少是能写的)
    //数据节
    strcpy((char*)m_newSecHdr[1].Name, ".data");
    m_newSecHdr[1].Misc.VirtualSize = GetAlign(m_dwComSecSize,m_pNtHdr->OptionalHeader.SectionAlignment);
    m_newSecHdr[1].VirtualAddress = m_newSecHdr[0].VirtualAddress + m_newSecHdr[0].Misc.VirtualSize;  //节表是连续的,等于上一个节表地址+大小
    m_newSecHdr[1].SizeOfRawData = m_dwComSecSize;   //节大小
    m_newSecHdr[1].PointerToRawData = m_pNtHdr->OptionalHeader.SizeOfHeaders;   //紧跟文件头
    m_newSecHdr[1].Characteristics = IMAGE_SCN_MEM_READ;//内存属性

    m_newSecHdr[1].PointerToRelocations = m_dwComSize; //压缩后的大小
    m_newSecHdr[1].PointerToLinenumbers = m_dwSrcPeSize; //压缩前的大小

    //代码节
    strcpy((char*)m_newSecHdr[2].Name, ".text");
    m_newSecHdr[2].Misc.VirtualSize = GetAlign(m_dwCodeSecSize, m_pNtHdr->OptionalHeader.SectionAlignment);
    m_newSecHdr[2].VirtualAddress = m_newSecHdr[1].VirtualAddress + m_newSecHdr[1].Misc.VirtualSize;  //节表是连续的,等于上一个节表地址+大小
    m_newSecHdr[2].SizeOfRawData = m_dwCodeSecSize;   //节大小
    m_newSecHdr[2].PointerToRawData = m_newSecHdr[1].PointerToRawData + m_newSecHdr[1].SizeOfRawData;   //上一个节文件地址+大小
    m_newSecHdr[2].Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;//内存属性

}

void CPacker::GetNewPeHdr()
{
    //拷贝原PE的PE头
    m_dwNewPeHdrSize = m_pNtHdr->OptionalHeader.SizeOfHeaders;
    m_pNewPeHdr = new BYTE[m_dwNewPeHdrSize];
    CopyMemory(m_pNewPeHdr,m_pDosHdr, m_dwNewPeHdrSize);

    auto pDosHdr = (PIMAGE_DOS_HEADER)m_pNewPeHdr;                                        //DOS头
    auto pNtHdr = (PIMAGE_NT_HEADERS32)((DWORD)m_pNewPeHdr + pDosHdr->e_lfanew);        //NT头
    auto pSecHdr = (PIMAGE_SECTION_HEADER)((DWORD)&pNtHdr->OptionalHeader + (pNtHdr->FileHeader.SizeOfOptionalHeader));

    //修改节表个数
    pNtHdr->FileHeader.NumberOfSections = 3;
    //修改入口点
    pNtHdr->OptionalHeader.AddressOfEntryPoint = m_newSecHdr[2].VirtualAddress;
    //修改在内存的总大小  
    pNtHdr->OptionalHeader.SizeOfImage = m_newSecHdr[2].VirtualAddress + m_newSecHdr[2].Misc.VirtualSize; //最后一个节的地址 + 大小

    //清空数据目录
    ZeroMemory(pNtHdr->OptionalHeader.DataDirectory, sizeof(pNtHdr->OptionalHeader.DataDirectory));

    CopyMemory(pSecHdr, m_newSecHdr, sizeof(m_newSecHdr));  //拷贝节表
      

}

bool CPacker::WriteNewPe(CString strNewPe)
{
    //创建文件
    HANDLE hFile = CreateFile(strNewPe,           // open MYFILE.TXT 
        GENERIC_WRITE,              // open for reading 
        FILE_SHARE_READ,           // share for reading 
        NULL,                      // no security 
        CREATE_ALWAYS,             // existing file only 
        FILE_ATTRIBUTE_NORMAL,     // normal file 
        NULL);                     // no attr. template 
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    DWORD dwBytesWrited = 0;
    //写入PE头
    WriteFile(hFile, m_pNewPeHdr, m_dwNewPeHdrSize, &dwBytesWrited, NULL);
    //写入数据结头
    WriteFile(hFile, m_pComSec, m_dwComSecSize, &dwBytesWrited, NULL);
    //写入代码节
    WriteFile(hFile, m_pCodeSec, m_dwCodeSecSize, &dwBytesWrited, NULL);

    CloseHandle(hFile);
    return true;
}

```

