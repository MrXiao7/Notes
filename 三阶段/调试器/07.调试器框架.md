**怎么确定eip所处在哪个模块下？**

这个你要遍历被调试进程。最简单的遍历方式就是快照。用枚举也行。他会返回模块的首地址，还有模块的大小，你就判断eip处在哪个范围就可以了。

**内存断点**

我来说说这个内存的断点。我这节课就写一个。支持多个内存断点的。首先你们要搞清楚这里面的数据关系。

**数据关系**

以下表中的数据都是16进制的。

![img](notesimg/1655361302515-4deb610c-f592-4b2b-b074-37b81a6adeea.png)

这前三个断点有重叠吗？没有吧、没重叠吧。但是这三个断点位于同一个分页内，或者一个分页内说它可以有多个内存断点的。

![img](notesimg/1655361303093-a0d92818-ac4b-4ebf-a842-24ad2cb87302.png)

发现这个分页还还有内存断点之间的关系，它是一个多对多的关系。那这两者的关系因为是个多对多关系，所以我们就需要建三张表了、

分页表要存：分页地址、原有内存属性。

比如有的断点表地址可能跨两个分页、这两个分页的内存属性可能不一样。所以你要有一个分页表去记录一下这些数据。分页表和断点表这两边其实这个地址都能够拿来当主键，但是看着不是很好看。给个编号吧、我们先把这个数据设计出来，其实你虽然完整的数据设计出来，但是不一定能够这些数据这些表上都会用上。例如下图的数据

![img](notesimg/1655361303583-97573d18-4d63-46c9-a3f9-5decc5eb6d4c.png)

首先增加我们说有两种情况被我们给干掉了、一种就是和某个断点有重合、我们就直接干掉不让他设置、然后就是如果是断页我们也不让它设置。所以我们就不考虑重合还有缺页的情况。

**查询**

比如说我现在要加一个断点，00401800长度是32。首先我们这个东西检查一下它有没有和断点表这里面的地址断点重合。跟这个00401100重合了、那这个不行。

00403400长度32这个不重合、可以在断点表插进去。然后在分页表中有00403000这个分页。那这个时候其实已经有断点用了这个分页，那说明这个它的内存属性已经被改掉了。那我只需要分页断点表这里加一下就行了。

![img](notesimg/1655361305220-2a010650-d3b8-46d6-8220-b74762dd3f73.png)

然后当异常来的时候，我们需要做查询判断断点是否命中、命中命中的话，我们看查哪个表吧。比如这个时候有个地址0040210C有个访问。它会命中的去哪个地方？。查哪个表？应该去查分页表、去查这个分页表，看是不是在范围内。

如果不是的话，那说明啥？说明压根儿不是我们的异常、所以直接就放掉。那如果说里面某个地方中了，比如说这是0040210C。这里面肯定会命中00402000。命中了这个分页表之后、去断点表中查询看这边命中了哪个断点。这个时候就命中00401100长度2000的这个范围了。这个时候断点就命中了。

你发现这个时候其实在查的时候只用到了这个分页表，还有这个断点表，这个分页断点表用不上。

**删除**

比如说删除某个断点。删断点的时候，我们要其实是要做的是恢复原来的内存属性、那删除的这个断点去哪查呀？你需要知道它涉及到几个分页、那就是需要到分页断点表去查了。要判断相同编号有几个如果数量大于二的话，就不能在分页表改内存属性了、只需要把分页断点表和断点表把对应的断点删除即可。如果数量是1个，那就可以还原内存属性。

我们需要把我们讨论的这些东西文档记录下来，这个到时候写代码思路比较清晰。



**设置断点：**

1、判断是否可以插入

1） 查询断点表，是否与已设断点重叠

2） 查询内存属性，是否有缺页

2、插入

1） 插入断点表

2） 获取所涉及到的分页

a. 查询分页表，如果存在，则直接添加到分页断点表

b. 查询分页表，如果不存在， 修改内存属性，并添加到分页表和分页断点表

**查询是否命中：**

1、查分页表， 如果没有命中分页，则不是自己异常，放过去

2、查分页表， 如果命中分页

1） 查断点表，如果没有命中，断步配合，放过

2） 查断点表，如果命中，则提示，并输入命令，断步配合重设

**删除：**

1、断点表删除

2、获取断点所涉及的分页，对每一个分页

1） 获取分页编号

2） 查询分页断点表，此编号数量

a. 如果只有一个，则从分页表和分页断点表删除，并恢复内存属性

b. 如果有多个，则从分页断点表删除



断点，我还得写一个输入断点的命令。将第五天的工程拷贝过来。

![img](notesimg/1655361307083-6bec4c5c-bea9-47f9-9f7f-a9e9c63693cf.png)

![img](notesimg/1655361308651-8f80e9f8-8a98-41eb-8ec2-61ca8b873695.png)

下图这些跟具体的逻辑没啥关系的，直接丢其他的文件里面。

![img](notesimg/1655361309357-73b2a418-dfef-435a-94b8-8a429546d8e4.png)

**新建文件**



![img](notesimg/1655361310274-41cde5ff-4760-4851-808d-2da16ffa4f7e.png)

![img](notesimg/1655361310736-386b0112-9f5b-4306-aa9c-3efdf5814c9e.png)



**导入文件**

![img](notesimg/1655361311399-54c1c74e-5193-40d8-a1aa-00f956f66e57.png)



![img](notesimg/1655361312432-f2e14289-3148-453d-b990-e9c849d555ff.png)



增加代码

![img](notesimg/1655361313466-28f690b4-f453-41ff-a928-29095051a703.png)

tool.asm代码敬上

```
.586
.model flat,stdcall
option casemap:none

   include windows.inc
   include user32.inc
   include kernel32.inc
   include msvcrt.inc
   include udis86.inc

   includelib user32.lib
   includelib kernel32.lib
   includelib msvcrt.lib
   includelib libudis86.lib


.code

IsCallMn  proc uses esi edi pDE:ptr DEBUG_EVENT, pdwCodeLen:DWORD
    LOCAL @dwBytesOut:DWORD
    LOCAL @dwOff:DWORD
    LOCAL @pHex:LPSTR
    LOCAL @pAsm:LPSTR

    mov esi, pDE
    assume esi:ptr DEBUG_EVENT

        ;显示下一条即将执行的指令
    invoke ReadProcessMemory, g_hExe, [esi].u.Exception.pExceptionRecord.ExceptionAddress, \
        offset g_szOutPutAsm, 20, addr @dwBytesOut
    invoke ud_init, offset g_ud_obj
    invoke ud_set_input_buffer, offset g_ud_obj, offset g_szOutPutAsm, 20
    invoke ud_set_mode, offset g_ud_obj, 32
    invoke ud_set_syntax, offset g_ud_obj, offset ud_translate_intel
    invoke ud_set_pc, offset g_ud_obj, [esi].u.Exception.pExceptionRecord.ExceptionAddress

    invoke ud_disassemble, offset g_ud_obj
    invoke ud_insn_off, offset g_ud_obj
    mov @dwOff, eax
    invoke ud_insn_hex, offset g_ud_obj
    mov @pHex, eax
    invoke ud_insn_asm, offset g_ud_obj
    mov @pAsm, eax
    invoke ud_insn_len, offset g_ud_obj
    mov edi, pdwCodeLen
    mov [edi], eax

    invoke crt_printf, offset g_szOutPutAsmFmt, @dwOff, @pHex, @pAsm

    mov eax, @pAsm
    .if dword ptr [eax] == 'llac'
        mov eax, TRUE
        ret        
    .endif

    mov eax, FALSE
    ret

IsCallMn endp

SetTF proc dwTID:DWORD
    LOCAL @hThread:HANDLE 
    LOCAL @ctx:CONTEXT

    invoke OpenThread, THREAD_ALL_ACCESS, FALSE, dwTID
    mov @hThread, eax

    mov @ctx.ContextFlags, CONTEXT_FULL
    invoke GetThreadContext, @hThread, addr @ctx

    or @ctx.regFlag, 100h

    invoke SetThreadContext, @hThread, addr @ctx
    invoke CloseHandle, @hThread

    ret

SetTF endp

DecEIP proc dwTID:DWORD
    LOCAL @hThread:HANDLE 
    LOCAL @ctx:CONTEXT

    invoke OpenThread, THREAD_ALL_ACCESS, FALSE, dwTID
    mov @hThread, eax

    mov @ctx.ContextFlags, CONTEXT_FULL
    invoke GetThreadContext, @hThread, addr @ctx

    dec @ctx.regEip

    invoke SetThreadContext, @hThread, addr @ctx
    invoke CloseHandle, @hThread
    ret

DecEIP endp

GetContext proc uses esi dwTID:DWORD, pCtx:ptr CONTEXT
    LOCAL @hThread:HANDLE 

    invoke OpenThread, THREAD_ALL_ACCESS, FALSE, dwTID
    mov @hThread, eax

    mov esi, pCtx
    assume esi:ptr CONTEXT

    mov [esi].ContextFlags, CONTEXT_ALL
    invoke GetThreadContext, @hThread, esi

    assume esi:nothing

    invoke CloseHandle, @hThread
    ret

GetContext endp

SetContext proc dwTID:DWORD, pCtx:ptr CONTEXT
    LOCAL @hThread:HANDLE 

    invoke OpenThread, THREAD_ALL_ACCESS, FALSE, dwTID
    mov @hThread, eax

    invoke SetThreadContext, @hThread, pCtx

    invoke CloseHandle, @hThread
    ret

SetContext endp



end
```

是不是call，这个是单步用的。此次模拟这里也不要单步了，要啥单步呀？直接反汇编就得了。

![img](notesimg/1655361314007-c4715e1a-abb0-4303-841b-2e24719e71d4.png)

改个名字

![img](notesimg/1655361314547-45b9d3d3-a447-49f3-ae82-7a88debf60a6.png)

修改成

![img](notesimg/1655361315071-01ad3127-ea79-4e3b-86bb-fee52c5d9c06.png)

这个代码我先归拢一下，归拢完之后我们再一起再整体再看一看。这些东西丢一个头文件去。

**新建头文件**

![img](notesimg/1655361317710-cb700a01-80f3-4719-a62b-069170e6fe1e.png)

![img](notesimg/1655361318317-01fdcee3-746c-4262-8fc8-9ea0f2830349.png)

![img](notesimg/1655361318994-b22fbf32-f25d-4bd7-aa77-5e62f55773d1.png)

![img](notesimg/1655361320335-dedda3cf-cb38-4a23-960d-51a6319b00bf.png)



![img](notesimg/1655361321304-61c9fd73-f6f4-4473-b210-e050a7091aa1.png)

![img](notesimg/1655361322453-233d1c00-6050-4fe6-b919-19c413651a11.png)

修改为

![img](notesimg/1655361323164-3e7501c4-baa8-4df4-b879-ccc510299856.png)

分析一下代码

![img](notesimg/1655361324027-4122aa07-01e3-41b9-b73f-65dd1cba102b.png)

程序跑起来的时候就设个断点。设个断点之后会来异常。然后去处理。其它代码就不动了。

删除代码

![img](notesimg/1655361325035-ea392f13-6e44-4f80-b097-ee25255e7f8c.png)



![img](notesimg/1655361326568-d9465fff-e4b2-45f3-8291-e3efe3c151e4.png)



![img](notesimg/1655361328176-543a0fd0-ceac-484f-85eb-da3a6984029e.png)



![img](notesimg/1655361329259-ba00f92e-3569-4ea0-ac60-fd3e7a33ce22.png)

这个逻辑其实不是很好处理。



然后反汇编一条，等待输入命令、注意scanf不行、因为scanf遇到空格会截断 。用gets。

![img](notesimg/1655361331238-2dd93b5d-098c-4785-8765-785d41969609.png)

![img](notesimg/1655361333506-62a09731-a961-4f2a-9760-f6ea8f29d8ba.png)

我就不信你这个能写二百五十六个字节。

![img](notesimg/1655361334620-d97036f1-efcc-4dcf-a37d-3b4d93a6d344.png)

**输入命令**

![img](notesimg/1655361335713-3a753a2f-bc1b-4fe5-ab21-85a2ffbef8bc.png)

必须是bpm 04001000 32这种格式的输入。

如果eax<=0说明按的是回车，只要按回车，那我就continue让你重新输入。

![img](notesimg/1655361337604-5e0ad50d-1b57-456e-ba0a-8d7008ef6e29.png)

**解析命令**

先试试这个语法行不行。

![img](notesimg/1655361341914-2eb9ce6e-5ad4-4e71-ba95-f6b76c038264.png)

不认识_DisasmOne@8

不认识_SetTF@4，

不认识_DecEIP@4。

这是因为链接的时候没有tool.obj

![img](notesimg/1655361345483-479da230-e9ca-4aa7-aa49-538df34c0c50.png)

**添加编译obj文件（编译多个文件）**

![img](notesimg/1655361347099-7f4b2481-ad44-469a-bcd7-50df4a044879.png)

![img](notesimg/1655361348682-9b10ac06-ca02-4fbe-9fd4-ce5716b86a7f.png)

![img](notesimg/1655361349219-d30afc0a-8894-43fc-9344-099e0dd4a312.png)

重新构建、一堆错误

![img](notesimg/1655361350704-d6fa3097-c9f8-4822-8bd3-011280fa650c.png)



![img](notesimg/1655361351931-a4f3a9be-efad-42ba-9b94-390f867ee4bb.png)

![img](notesimg/1655361352895-d45687d8-6d47-487b-bc5f-b76892192288.png)

g_szOutPutAsm也剪辑过去。

![img](notesimg/1655361354208-2e3768f7-1c9a-41e9-8b6e-3777903ad609.png)

![img](notesimg/1655361355585-61fadf6f-701f-4727-a629-a56953745d4e.png)

需要进程句柄【个人理解进程句柄g_hExe之所以用externdef没有从主界面搬过来是因为这个进程就是从主界面拿的】

![img](notesimg/1655361357656-77e51757-a017-4891-916a-e9f4a165de1c.png)

![img](notesimg/1655361358770-0ad64bdb-22d7-486e-81bc-8de6d4d6c583.png)

构建

![img](notesimg/1655361359773-be24c8bd-6330-4c89-9a44-8824accbee5d.png)

解决办法：public一下。

![img](notesimg/1655361362367-4a8897f8-71aa-4933-bd36-644abe7c21e7.png)

构建ok 完事儿。

**解析命令**

就比如ml是把这个都列出来，、

![img](notesimg/1655361363407-fd42fc99-eba0-4e65-9c11-2e153ee5dcdc.png)

这个样子写的话，你发现它其实马上匹配bpm，匹配了bpm之后，它就匹配不上bpml了，所以一般就是长的给它放上面、短的给它放下面。

![img](notesimg/1655361365223-35517492-ed6b-4925-9358-d7cde4e9e0d1.png)

这样的话他会先判断长的，长的不行就再判断短的。越短的话就放下面去。

应该是bm不是bpm、它这都是一个字母，多麻烦。换成bm吧。

![img](notesimg/1655361366084-cca2f1aa-908a-4d5d-982f-7c6db66d9271.png)

g命令其实没不用做别的，直接让他直接跑就行了，、

![img](notesimg/1655361366813-cf115603-dabf-4f73-bdcf-a36eaec70ca2.png)

![img](notesimg/1655361367961-68ac47a3-1d5c-4edc-8ea1-dbc593b26641.png)

**解析命令**

设置内存断点之前，你需要把这个内存断点的命令给它解析完，bm后面接着是地址，再接着是长度。

c 库是有函数的。

strtoul：

str -- 要转换为无符号长整数的字符串。

endptr -- 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。

base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。





返回值

该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。

实例

下面的实例演示了 strtoul() 函数的用法。

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
   char str[30] = "2030300 This is test";
   char *ptr;
   long ret;

   ret = strtoul(str, &ptr, 10);
   printf("数字（无符号长整数）是 %lu\n", ret);
   printf("字符串部分是 |%s|", ptr);

   return(0);
}
```

让我们编译并运行上面的程序，这将产生以下结果：

数字（无符号长整数）是 2030300

字符串部分是 | This is test|



![img](notesimg/1655361368856-3562e5f8-b8a1-458d-8327-16ad6cf31f8e.png)



![img](notesimg/1655361369586-49a911d4-99c2-4ecb-935f-4b37dd12ce24.png)

@pEnd传输参数干啥用？它一般你比如说你传进去的指针在这个位置，然后它会自己跳过前面的空格，然后遇到数字开始解析。解析完之后，这里告诉你这最后一个地方下一个字母在哪个位置。所以你再次下次再解析的时候，到时候你直接给他这个就可以了。

给@pEnd当地址就可以紧接着判断长度了

![img](notesimg/1655361370708-fbf993ad-ce39-4819-91b5-0f31d60ac838.png)

回来之后，我需要一个就变量把这个地址存一下。

![img](notesimg/1655361371847-656e0b3a-0bc6-4d19-a61c-3503a7a8e3e2.png)

你不可能在零地址上设设断点，在零地址上啥断点都不能设呀，这个strtoul解析出错的话，返回值就是零。

![img](notesimg/1655361373337-efb8cd59-9050-4b03-b6ff-431e7d4a4b10.png)

**长度**

直接拿刚才@pEnd传出参数的位置就是可以解析长度。

![img](notesimg/1655361374513-6af2bd31-369d-4a76-8d9d-091fdbee5e0a.png)



![img](notesimg/1655361375353-f70295b0-bf26-40cc-b40c-28aef3b135d7.png)

有了这个之后，我们就可以去设置内存断点了。我内存断点有三张表、所以来吧，再来个文件别都写到这里了。

**新建文件**

头文件和原文件

![img](notesimg/1655361375912-c171914e-1508-4406-8de7-f80b8ecd071d.png)



![img](notesimg/1655361377972-d83e79e5-c2b7-4572-b6c0-8d93c1a43cea.png)

**工程选项添加编译链接文件**



![img](notesimg/1655361379144-30a55193-4bf7-4d8d-bcad-eca3ff686450.png)



![img](notesimg/1655361380091-a6052031-2067-4073-b5a1-6a9dc3377591.png)



![img](notesimg/1655361380843-60e6a8b6-7113-4d8b-b0f5-b03030d44a64.png)

那我们这边就让他调个函数完事儿。函数名字SetBm然后他地址需要给我传进来。然后还需要传进来长度。

类型此次模拟没有输入。我就默认全部都是访问类型的断点。

![img](notesimg/1655361383789-8f419629-910b-45d9-b6b4-9f5714953d07.png)

这边我就需要有三张表、

分页表需要三个字段（编号分页地址原有属性 ）、

这个分页断点表需要两个字段（分页编号断点编号 ），

这个断点表是需要三个字段（编号地址长度 ）。

我就用数组了，钟情于数组。

**分页表**

![img](notesimg/1655361384473-eecff498-0fd3-432a-9943-d59e03fd5688.png)

然后我这个分页，我给他准备多一点儿。那一百个。

![img](notesimg/1655361385499-c258bad1-5bbb-4991-9007-09c87a794280.png)

这里面我还要存一个个数、你得知道有几个。

![img](notesimg/1655361386048-f6905b9a-52c8-4d48-ab7b-1e6c37975878.png)

**分页断点表**

![img](notesimg/1655361386722-d09a44c2-937b-4f06-8ed2-a2f9ba4835f0.png)

那给两百个了、反正内存也不值钱。

![img](notesimg/1655361387571-cc8ba0eb-9980-42aa-8b05-b5e28f1c8425.png)

**断点表**

给一百个吧，已经很多了。

![img](notesimg/1655361388592-05f77d1a-8f92-4ebc-82d1-ecbcd56c048e.png)

先构建一下，看看我写的这些语法有问题不没问题、没问题。ok 那就没问题。

**目录分割**

**判断是否可以插入**

写个函数吧，

![img](notesimg/1655361390072-2501e6be-5b6c-40e1-8ade-fe9abb223dc8.png)

SetBm中调一下IsCanInsert。

![img](notesimg/1655361391274-7f53bf38-c81c-4321-8662-d0fa122189a5.png)

其实不用给0d 0a直接调用puts就完事了。不用printf也可以。

**查询断点表，是否与已设断点重叠**

ecx用来计数、每次自增。挨个遍历。

![img](notesimg/1655361393747-f57c901e-78ac-4e00-bf7a-facf4ab22250.png)

再写个函数吧，不然这太麻烦。

![img](notesimg/1655361395303-4cfc10e8-9f78-42d5-9bca-7bbbab44d1a4.png)

![img](notesimg/1655361396403-71b10c18-7284-4e90-9fe9-6210353205e8.png)

判断是否有重叠，这个咋判断？

重叠就是下图的这两种情况。

![img](notesimg/1655361398607-2655b7dc-3a51-43a8-a6ba-280a9147e9f1.png)

那我就判断一下，先判断1的首地址在不在0的范围内。再判断0的首地址是不是在1的范围内。有一种情况发生的话，说明就有重叠、、

**判断0的首地址是否在1的范围内**

一旦在范围内可以返回FALSE。

![img](notesimg/1655361399089-25148524-6bf4-4da2-a398-18673205408b.png)

用几个寄存器吧，反正这代码也不多，寄存器我们也多的是.肯定够用。

![img](notesimg/1655361400495-c8160163-5f51-45f5-9ca4-3c3a83c4cea0.png)

![img](notesimg/1655361401699-7a6eb38e-f6df-4925-b340-3032ded2ed3c.png)

**判断1的首地址是否在0的范围内**

![img](notesimg/1655361402458-87d1badd-4832-430f-920c-f7047da68fc4.png)

IsCanInsert调用一下

**是否有重叠**

IsCanInsert调用一下IsOverlapped

![img](notesimg/1655361403298-07b647a3-5173-4434-aa4f-bfb72260f14d.png)

![img](notesimg/1655361404313-c51c0bcd-63dd-4498-9ada-12a1db5b1a7a.png)

![img](notesimg/1655361405656-5ef7f078-ebd9-4fb6-bdd1-f76db118ecd1.png)

**是否有缺页**

VirtualQueryEx:1:30处有验证这个api的作用。判断它有几个分页，然后每个分页都都来查一下状态是否是一千？一旦有一个分页不是一千的话，那我们直接把它干掉。当然没别的招了、因为它的这个一个内存可能会跨页的。

怎么算这个分页？

![img](notesimg/1655361406451-cd4464ae-21f0-4688-883f-fb1c454588d5.png)

![img](notesimg/1655361407963-7022a0dc-2e54-4de2-987e-2f30e4150e2d.png)

之所以push ecx  pop ecx因为很多api它压根都不存ecx，也不存ebx。【但是我发现ecx保存的分页个数好像没没啥用】

![img](notesimg/1655361409001-43453cff-d9b2-4847-9a01-087ff002829c.png)

**插入**

![img](notesimg/1655361410547-f2abe8da-dd57-44d3-8c6d-f1930a080582.png)

接下来是插入。插入首先是存到这个断点表里面。

**存入断点表**

![img](notesimg/1655361412381-b6ab5e7f-abe9-4ba2-9888-7a2b983e1d42.png)

还有编号。我这个编号也不能用个数来当，因为个数删了的话，编号就重了。

来个编号吧。

![img](notesimg/1655361413256-c7823991-90bc-483a-b5f6-0298590ce3d4.png)

编号从零开始。然后每次自己加1

**存储编号**

![img](notesimg/1655361414743-bbede33b-5119-4be8-9833-965616e79456.png)

**存储地址**

![img](notesimg/1655361415239-e9d7de3d-44d9-4ff0-a795-035d491d8a36.png)

**存储长度**

![img](notesimg/1655361415923-a20e42ee-a92a-4bdc-8d6b-c5a0fdf36964.png)

![img](notesimg/1655361417369-aa954185-4558-4d15-a96a-c54581773e0b.png)

**存入分页表**

![img](notesimg/1655361419387-12487908-267c-4bb7-afcc-a09841661cb6.png)

![img](notesimg/1655361420970-04a2dcb4-20fc-4a39-9664-57ca93550ad2.png)

直接来个函数吧，、

![img](notesimg/1655361421616-5aba5b80-1bee-4081-bcea-f15e13d576c5.png)

有的话就加进去。

**查询分页表**

如果存在，则直接添加到分页断点表

![img](notesimg/1655361423288-af0add8d-6bf2-47e1-a07b-e00750ced714.png)

如果不存在， 修改内存属性，并添加到分页表和分页断点表



这边也有个i d，你要有个i d 值。

![img](notesimg/1655361424531-167fefc8-1d64-499f-9bf7-f19916b87e4f.png)

![img](notesimg/1655361425605-f43441fb-c4c2-4797-88e4-1dbf1b514c62.png)

然后还要加到分页断点表、分页断点表我还需要知道知道两个编号才能加进去。

算了直接封装一个AddToPageBpTable函数吧

![img](notesimg/1655361427451-e85d90f3-70c6-4b45-bcb7-7640f37ff753.png)

**加到分页断点表**

断点的id肯定是新的，就是以前不存在的。所以直接拿g_dwID即可。

![img](notesimg/1655361429929-f6b3cb8d-dff4-4ea0-bf2f-cf9962f60dd8.png)

**分页表已经存在直接加**

断点的id肯定是新的，就是以前不存在的。所以直接拿g_dwID即可。

![img](notesimg/1655361431620-cc521fae-7665-461f-8f64-e6d57e417a19.png)

![img](notesimg/1655361433632-3545abca-d72b-4569-a25c-55ebcf5110aa.png)

添加代码

![img](notesimg/1655361435361-c68101f3-9ba5-478e-8400-268137566350.png)

设置写完了，设置完之后，函数声明声明一下。

![img](notesimg/1655361436821-91568b6b-a825-4da2-a2b1-6d9e37e2de99.png)

**构建报错**

![img](notesimg/1655361437398-1fbcc38e-7c34-4e3a-88f4-10babfc2a921.png)

解决办法：声明一下

![img](notesimg/1655361441401-ad0d1d1b-ba67-4e4e-bf25-100d5817e405.png)

还报错

![img](notesimg/1655361443221-f4aa1a93-6589-42e9-a59e-88567f16b03d.png)

我发现是我这里不能直接加的原因

![img](notesimg/1655361444045-c09d2f9f-9d3f-4bc7-875a-d043a4c08eb9.png)

修改成



![img](notesimg/1655361444690-02b2f5f5-49f4-49cd-9870-794f2c629215.png)

**设置内存断点**

![img](notesimg/1655361446178-22344d9c-f289-44b4-b5e9-5fe96865e6bd.png)

完了之后，这边就要去调调处理异常、



![img](notesimg/1655361447815-41391b0b-352c-4a0f-bb40-9e38bea30e82.png)

**内存断点**

这里这个时候不在这边输命令了，然后自己统一把命令去。

给个标志。

![img](notesimg/1655361448336-8e02f4c3-c255-42b8-8228-f642fd33e1e8.png)

![img](notesimg/1655361449314-44b8dc54-988c-43c4-9476-0adbb4f60850.png)

他需要输入命令的。

![img](notesimg/1655361451052-6e67512a-6fa4-41ca-85be-c81d7e5121a6.png)

![img](notesimg/1655361455544-682b56f3-c03f-483f-b989-354dffcdda03.png)

内存来了之后看一下。最后的时候。如果说是需要输入命令的话。就是下面的代码

![img](notesimg/1655361456740-bf01bb04-65e5-4bf7-900d-0321f8e408d4.png)

这里肯定是要跑起来的。我这边感觉返回值还有点不够。

**内存断点**

这里是内存断点，我需要去调一下。让内存这边去处理一下。

![img](notesimg/1655361457742-45d15e91-8227-4edf-a5bd-f9d000a6a350.png)

这边所有的表都在这里、所以在这个Membp.asm文件里面去处理这个干净。

![img](notesimg/1655361460396-8c8ef617-28d9-4055-839d-6bdae2974d39.png)

声明一下

![img](notesimg/1655361462005-a5118c87-0d50-4040-a78d-b5ecc92c77f8.png)

![img](notesimg/1655361463729-1787c244-e2a0-4da3-b367-38b01b094ce8.png)

这个时候需要判断的是到底要不要去处理。要不要输命令，我这边就简单一点。其实这边OnNoAccessException的返回值应该给多个。

![img](notesimg/1655361465507-f7064bc3-bdd3-491b-ac7f-83c1da5fdfdd.png)

![img](notesimg/1655361466666-1a98ff69-6881-41b7-9baf-8c4a6280b4c5.png)

然后这个是单步、所有的单步都要让他们去自己去处理一下。

![img](notesimg/1655361468131-7490eab0-5f7a-4b5f-92c6-129d6166dc57.png)

他的单步其实永远是不需要处理的。【不理解】

![img](notesimg/1655361469720-7a4f12cd-3d41-46cb-b48f-8149db8826d4.png)

![img](notesimg/1655361470682-24c35a6f-3fc5-4221-833c-f162519c823b.png)

自己去判断要不要处理，反正就是把这个内存的单步给它调一下。

![img](notesimg/1655361471475-9185bb38-1258-47a5-b4ac-f299f3f51b55.png)



然后这边的一般单步会有很多。所以后面的每个逻辑都让他们自己处理一下。比如说后面可能是处理T命令单步。处理CC单步

![img](notesimg/1655361472383-1a1090f4-7ae4-4671-8bfb-23f099ec1ddd.png)

都通过返回值判断要不要去重新输入命令。

然后后面是查询是否命中：

![img](notesimg/1655361474525-85b73dbb-7053-40ab-8f1b-9d25614f4860.png)

我这里就简单点，我就判断是否命中。不然我这个写不完了，就连一个断点就实现不了。

![img](notesimg/1655361475155-1ec6e520-6bdf-4d58-9ecf-22079facd009.png)



![img](notesimg/1655361475585-262e8d79-f4c6-49a1-91c7-8de48af75c04.png)

![img](notesimg/1655361476103-bf7809d1-d69b-4c5c-829d-3a00df2cdd0a.png)

然后判断地址。判断这个地址是否是位于断点的范围内。

**判断断点是否命中**

![img](notesimg/1655361476581-8b24f4f8-c8db-47c2-b947-bc96b30117fc.png)

这边的返回值我需要存一下。默认的FALSE、表明是不需要的。

![img](notesimg/1655361479805-f6e06c95-d873-42f1-9164-ba2888884d1c.png)

然后如果命中的话，那它就需要输入命令了。我要做个提示。

![img](notesimg/1655361480793-6bd6db7e-93cf-4631-b211-ae1f2cef18ad.png)

判断一下是否命中。



![img](notesimg/1655361481965-d3996001-3376-4d53-b62e-237b458e3f61.png)



![img](notesimg/1655361485056-b446d2cd-10ec-4732-a420-6be310ccf19d.png)

调用一下输出

![img](notesimg/1655361486201-b94a5a38-3818-4886-b7e6-a62005990e69.png)

![img](notesimg/1655361487075-14acd410-7721-4ea6-9b6f-51b402fc25dd.png)

修改代码

![img](notesimg/1655361488185-c219b1a3-8988-4d51-aa1f-63374d29476e.png)

修改为

![img](notesimg/1655361489276-7f8642eb-996b-4cd3-99f1-e8daee857ced.png)

但是不管命中、不命中，我都要去做断步配合。

**断步配合，恢复原来内存属性，设置单步**

设置单步直接调用invoke SetTF, [esi].dwThreadId就完事了。

![img](notesimg/1655361491685-0af35775-2343-4034-87bb-13d33eb6c317.png)

![img](notesimg/1655361493736-155450ae-323b-46aa-88ae-0bda15a70951.png)

接着就是断步配合。其实就是恢复原来内存属性。

![img](notesimg/1655361494500-fd1ba6e0-e186-429d-822c-83ed22571ecc.png)

这个地址我得知道它的原先的内存属性，保证它原先的属性我就需要去分页表里面去查、。

![img](notesimg/1655361498554-f230991c-6944-438c-ab12-c3b4c6aad7c4.png)

**查表**

![img](notesimg/1655361500785-de1197ff-0c6a-400e-a1c4-4a1168b0c296.png)

![img](notesimg/1655361502089-49010810-d338-4c87-a5dc-729c6c72c46a.png)

esi已经被我用了，所以我就只能用edi了。

![img](notesimg/1655361503969-a32c7558-f2e3-4d73-9ab6-c8e7fc4d2241.png)

![img](notesimg/1655361504929-b98d294d-31d5-4554-9969-1319db117372.png)

![img](notesimg/1655361507975-7489b387-1aef-4d5b-a77f-98f2b405a9e3.png)

相等的话就修改内存属性。

![img](notesimg/1655361510345-cbacc61a-b13b-47fc-9773-cbf0ef44c8e6.png)

我回头我还得把这个重设、所以我这个单步，我需要给个标志重设的标志。

**重设标志**

![img](notesimg/1655361511588-f52209fc-89a1-45da-8df1-40467e426e24.png)

重设的时候还需要知道是哪个地址需要重设。

![img](notesimg/1655361515965-6d0d03f4-e374-4f2a-b598-577f6c04c529.png)

因为设的是单步，单步的话，执行完这条指令就来了。

设置单步之后给个标志。

**通知单步重设断点**

![img](notesimg/1655361517521-4e712cd4-6021-48fc-9cd9-da45def32f5a.png)

通知单步重设断点、然后断点的地址我要存一下。

![img](notesimg/1655361518571-c192c3c6-f9c3-4759-abf0-569eb3936869.png)

这个东西可以放到while外面去了

![img](notesimg/1655361521185-65011fba-2358-406f-8136-8a6a831ae497.png)

重设内存断点、需要重设的时候才重设，不需要重设就不重设了。

![img](notesimg/1655361522114-80ce24a3-3a21-40dd-91d6-7c3cac7788de.png)

其实应该只要去掉它的读写属性就可以了。

**构建**

![img](notesimg/1655361524169-7ecb375b-0b53-46a7-b4ba-8c42f8ced431.png)

没有包含头文件所以报错。

![img](notesimg/1655361524895-d613377c-7b57-4eb6-bf6e-26c5054312b5.png)

继续包含头文件

![img](notesimg/1655361526333-08a6cfca-dc18-4886-a2e5-292873b44e1b.png)

![img](notesimg/1655361526945-88080919-22db-4142-a59d-970bea5ca50d.png)

完事儿是完事儿，能不能跑另说。不能用扫雷这个程序、它这个内存还是感觉跑起来很难受。我要去自己写个程序去测一测。

**新建工程**

![img](notesimg/1655361527905-0047ec65-d171-47fb-9647-cd369e63c8e0.png)

![img](notesimg/1655361530105-542915f0-9682-400e-b916-3665b4c8cfac.png)

下一步下一步完成。

准备一个大数组。其他的不要了。

![img](notesimg/1655361530452-0bc97130-a1ac-4b16-ab67-777a05502f05.png)

别的不管。留下以下代码

```
.586
.model flat,stdcall
option casemap:none

   include windows.inc
   include user32.inc
   include kernel32.inc

   includelib user32.lib
   includelib kernel32.lib


WinMain proto :DWORD,:DWORD,:DWORD,:DWORD


.data
   ClassName db "MainWinClass",0
   AppName  db "Main Window",0
   g_ary dd 10000h dup(0)
.data?
   hInstance HINSTANCE ?
   CommandLine LPSTR ?

.code


; ---------------------------------------------------------------------------


start:

invoke ExitProcess,eax
end start
```

![img](notesimg/1655361531819-b8e22e39-9dcb-45ac-8e62-fa45421d0d58.png)

完事之后，我让他自己弹一下。

![img](notesimg/1655361532900-7ea27888-f4d8-4329-8eeb-fd27e42833d5.png)

这样我就有个固定地址就可以测了，不然这个地址来回变变的。不好测试。

**运行测试**

![img](notesimg/1655361536997-92a532a4-599b-420a-8dea-22e5a0128cc6.png)

![img](notesimg/1655361538230-1200572c-51c7-4395-a0ae-01f579394b87.png)

修改为test程序

![img](notesimg/1655361542234-42cd638d-3bbc-414f-8ce1-dc3b529ea29c.png)

![img](notesimg/1655361543493-a3e24b8d-7325-4184-b37c-126c7bbe197d.png)

我这边要设个断点，给他设个断点地址，我找一下地址去这个地址是00403019，我要在这里00401000下个断点。

![img](notesimg/1655361544918-ed8cab01-8cad-41e3-bb80-7694aedde382.png)



![img](notesimg/1655361547014-e59b8a73-6d25-4d66-a24e-79d7a0599c7a.png)

**运行测试**

![img](notesimg/1655361548091-294a3349-0d4e-4d7b-bf5a-9bb6cb80b0a1.png)

运行过这两条之后发现程序直接退了。

原来是我没有加长度。emmm

加了长度还是不行，

![img](notesimg/1655361549061-d7b9df32-df53-42ac-86c2-af5ada4b5fec.png)

3：02有调试过程。

修改代码

![img](notesimg/1655361549786-41fb2e36-68de-4e9b-bb70-d0194d6f8948.png)

修改为

![img](notesimg/1655361550724-6820f8d9-9f0f-4618-be88-dc0468515e47.png)

我这边的返回值不够多，所以很多情况判断不了。

**运行测试**

我少了写了一个代码

![img](notesimg/1655361551617-da10b957-465c-4d23-bcc5-42eee7aa2f4c.png)

![img](notesimg/1655361552757-9a7bb53e-cb23-48df-9115-c4c7b88487bf.png)

![img](notesimg/1655361556017-ac0c93d3-ebfc-4f3d-8503-17d6810fd6de.png)

重新构建运行测试

我发现老王的代码有一处逻辑不正确。但是我这样写也不对。

下图是我写的。

![img](notesimg/1655361560143-339f8d77-9ee7-4398-9282-a19898fabced.png)

再看看老王的。老王这个地址跟长度比较肯定有问题。

![img](notesimg/1655361561215-51121ce2-ec76-484d-be9a-3db64f93782a.png)

算了就跟着老王的代码先模拟算了。就先按错的来。

![img](notesimg/1655361564201-e3eabcf9-3c86-4318-a4e0-290de5443bcc.png)

3：04调试。

刚开始设置命令的时候bm 00403020 10 所以是判断16次、个人理解16进制的10、就是10进制的16、因为我的长度是16个所以g  16次就弹出界面了。

![img](notesimg/1655361565248-a0c4b447-03db-4820-847b-4ab427b622d6.png)

这好像还多了一次、17次。因为我这是<=

![img](notesimg/1655361565854-bc47c1b8-8d14-4fc5-8e42-8a39a4852150.png)

行了吧，后面的可能还有一点点小bug，但问题不大。我就不调了。不能让我给你调完嘛，过分了。给你们打了个样、仅供参考。